<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Population vs CO2 Emissions Analysis</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  <style>
    body {
      font-family:Arial, Helvetica, sans-serif;
    }
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }

    .tooltip {
      position: absolute;
      padding: 8px;
      background-color: rgba(0, 0, 0, 0.7);
      color: white;
      border-radius: 4px;
      pointer-events: none;
      font-size: 12px;
      display: none;
    }
  </style>
</head>
<body>
  <h1>Population & CO₂ Footprint Visualizer 1970-2010</h1>

  <div class="slider-container">
    <label for="year-slider">Year: <span id="year-display">1970</span></label>
    <input type="range" id="year-slider" min="1970" max="2010" step="10" value="1970">
  </div>

  <div id="tooltip" class="tooltip"></div>
  <svg id="co2" height="800" width="1200" style="background: #fff; margin-top: 50px"></svg>
  <svg id="population-chart" height="500" width="1000" style="background: #fff; margin-top: 50px"></svg>
  
  
  <script>
    let world, co2_emissions, population_data, country_coordinates;
    let specificYear = 1970; 


    async function requestData() {
      // Load data 
      world = await d3.json("./countries-110m.json");
      co2_emissions = await d3.csv("./co2_emissions_kt_by_country.csv", d3.autoType);
      population_data = await d3.csv("./world_population.csv", d3.autoType);
      country_coordinates = await d3.csv("./country-coordinates.csv", d3.autoType);

      console.log("Data loaded:", { world, co2_emissions, population_data, country_coordinates });

      // Draw initial year
      drawMapAndChart(specificYear);

      // slider
      d3.select("#year-slider").on("input", function() {
        specificYear = +this.value; 
        document.getElementById('year-display').textContent = specificYear;
        drawMapAndChart(specificYear); 
      });
    }

    function drawMapAndChart(year) {

      // Clear previous drawings
      d3.select("#co2").selectAll("*").remove();
      d3.select("#population-chart").selectAll("*").remove();

      const co2_svg = d3.select("#co2");
      const co2_width = co2_svg.attr("width");
      const co2_height = co2_svg.attr("height");
      const co2_map = co2_svg.append("g");

      const projection = d3.geoMercator().scale(200).translate([co2_width / 2, co2_height / 1.4]);
      const path = d3.geoPath().projection(projection);

      const countries = topojson.feature(world, world.objects.countries).features;
      const co2DataForYear = co2_emissions.filter(d => d.year === year);
      const co2Data = new Map(co2DataForYear.map(d => [normalizeCountryName(d.country_name), d.value]));
      // Tooltip for displaying CO2 information
      const tooltip = d3.select("#tooltip");

      // Get top 10 countries by population for the specific year
      const populationYearKey = `${specificYear} Population`;
      const topCountries = population_data.sort((a, b) => b[populationYearKey] - a[populationYearKey]).slice(0, 5);

      // Create a set of the top 10 country names for faster lookup
      const topCountryNames = new Set(topCountries.map(d => normalizeCountryName(d['Country/Territory'])));

      // Assign colors to the top 10 countries and use grey for the rest
      const colorScalePopulation = d3.scaleOrdinal()
                                     .domain(topCountryNames)
                                     .range(d3.schemeTableau10); 

      // Default grey color for other countries
      const defaultCountryColor = "#d3d3d3";

      // Draw countries with population-based coloring
      const populationLookup = Object.fromEntries(
        population_data.map(d => [normalizeCountryName(d['Country/Territory']), d[populationYearKey]])
      );

      co2_map.selectAll("path.country")
             .data(countries)
             .join("path")
             .attr("class", "country")
             .attr("d", path)
             .attr("opacity", 0.65)
             .attr("fill", d => {
               const countryName = normalizeCountryName(d.properties.name);
               return topCountryNames.has(countryName) ? colorScalePopulation(countryName) : defaultCountryColor;
             })
             .attr("stroke", "black")
             .attr("stroke-width", 0.5)
             .on("mouseover", (event, d) => {
               const countryName = normalizeCountryName(d.properties.name);
               const co2Value = co2Data.get(countryName);
               if (co2Value) {
                 tooltip.style("display", "block")
                        .html(`<strong>${countryName}</strong><br>CO₂ Emissions: ${co2Value.toLocaleString()} kt`);
               }
             })
             .on("mousemove", event => {
               tooltip.style("top", (event.pageY + 15) + "px")
                      .style("left", (event.pageX + 15) + "px");
             })
             .on("mouseout", () => {
               tooltip.style("display", "none");
             });

      // Map country codes to coordinates for CO2 density contour
      const country_coordinates_map = new Map(country_coordinates.map(d => [normalizeCountryName(d.name), [d.longitude, d.latitude]]));

      const co2DataWithCoords = [];
      co2_emissions.forEach(d => {
        if (d.year === specificYear) {
          const coordinates = country_coordinates_map.get(normalizeCountryName(d.country_name));
          if (coordinates) {
            co2DataWithCoords.push({
              value: d.value,
              position: projection(coordinates),
              year: d.year,
            });
          }
        }
      });

      console.log(co2DataWithCoords);

      // Contour Generator (this should go below the country borders)
      const contourGen = d3.contourDensity()
                           .x(d => d.position[0])
                           .y(d => d.position[1])
                           .size([co2_width, co2_height])
                           .thresholds(20)
                           .bandwidth(20);

      const contours = contourGen(co2DataWithCoords);

      // Color scale for CO2 density contours
      const valueExtent = d3.extent(contours, d => d.value);
      const colorScale = d3.scaleSequential(d3.interpolateReds).domain(valueExtent);

      // Draw contours (place behind country borders)
      const contourLayer = co2_map.append("g").lower();
      contourLayer.selectAll("path.contours")
                  .data(contours)
                  .join("path")
                  .attr("class", 'contours')
                  .attr("fill", d => colorScale(d.value))
                  .attr("d", d3.geoPath())
                  .attr("stroke", "none")
                  .attr("opacity", 1);

      // Keep country borders above contours
      co2_map.selectAll("path.country-border")
             .data(countries)
             .join("path")
             .attr("class", "country-border")
             .attr("d", path)
             .attr("fill", "none")
             .attr("stroke", "#333")
             .attr("stroke-width", 0.7);

             const legendWidth = 300, legendHeight = 10;
      const legend = co2_svg.append("g")
                            .attr("transform", `translate(${(co2_width - legendWidth) / 2}, ${co2_height - 50})`);

      const defs = legend.append("defs");
      const linearGradient = defs.append("linearGradient").attr("id", "legend-gradient");
      linearGradient.selectAll("stop")
                    .data(d3.range(0, 1.05, 0.05))
                    .enter().append("stop")
                    .attr("offset", d => d)
                    .attr("stop-color", d => colorScale(d * valueExtent[1]));

      legend.append("rect")
            .attr("width", legendWidth)
            .attr("height", legendHeight)
            .style("fill", "url(#legend-gradient)");

      const legendScale = d3.scaleLinear()
                            .domain(valueExtent)
                            .range([0, legendWidth]);

      const legendAxis = d3.axisBottom(legendScale).ticks(5).tickFormat(d3.format(".2s"));
      legend.append("g")
            .attr("transform", `translate(0, ${legendHeight})`)
            .call(legendAxis)
            .selectAll("text")
            .attr("class", "legend-label");

      // Population Bar Chart
      const margin = { top: 50, right: 50, bottom: 100, left: 120 };
      const chart_svg = d3.select("#population-chart");
      const chart_width = chart_svg.attr("width") - margin.left - margin.right;
      const chart_height = chart_svg.attr("height") - margin.top - margin.bottom;
      const chartArea = chart_svg.append("g")
                                 .attr("transform", `translate(${margin.left}, ${margin.top})`);

      // Update to use specific Year
      population_data.forEach(d => {
        d[populationYearKey] = Number(d[populationYearKey]);
      });

      const top5Countries = population_data.sort((a, b) => b[populationYearKey] - a[populationYearKey]).slice(0, 5);

      const populationScale = d3.scaleLinear()
                                .domain([0, d3.max(top5Countries, d => d[populationYearKey])])
                                .range([0, chart_width]);

      const countryScale = d3.scaleBand()
                             .domain(top5Countries.map(d => normalizeCountryName(d['Country/Territory'])))
                             .range([0, chart_height])
                             .padding(0.5);

      // Drawing axes + labels
      const leftAxis = d3.axisLeft(countryScale);
      const bottomAxis = d3.axisBottom(populationScale).tickFormat(d3.format(".2s"));
      chartArea.append("g").attr("class", "y axis").call(leftAxis);
      chartArea.append("g").attr("class", "x axis").attr("transform", `translate(0, ${chart_height})`).call(bottomAxis);

      chartArea.append("text")
               .attr("class", "y label")
               .attr("text-anchor", "middle")
               .attr("font-weight", "bold")
               .attr("transform", `translate(${margin.left - 175}, ${margin.top - chart_height / 2 + 300}) rotate(-90)`)
               .text("Countries");

      chartArea.append("text")
               .attr("class", "x label")
               .attr("text-anchor", "middle")
               .attr("font-weight", "bold")
               .attr("transform", `translate(${margin.left + chart_width / 3}, ${margin.top + chart_height})`)
               .text("Population");

      // Draw bars for population chart
      chartArea.selectAll('rect.bar')
               .data(top5Countries)
               .join('rect')
               .attr('class', 'bar')
               .attr("x", 0)
               .attr("y", d => countryScale(normalizeCountryName(d['Country/Territory'])))
               .attr("fill", d => colorScalePopulation(normalizeCountryName(d['Country/Territory'])))
               .attr("width", d => Math.min(populationScale(d[populationYearKey]), chart_width))
               .attr("height", countryScale.bandwidth());

      // Add population text inside each bar
      chartArea.selectAll('text.population')
               .data(top5Countries)
               .join('text')
               .attr('class', 'population')
               .attr("x", d => populationScale(d[populationYearKey]) - 70)
               .attr("y", d => countryScale(normalizeCountryName(d['Country/Territory'])) + countryScale.bandwidth() / 2 + 5)
               .attr("fill", "black")
               .attr("font-size", "12px")
               .attr("text-anchor", "start")
               .text(d => d3.format(",")(d[populationYearKey]));
    }

    // Utility function to normalize country names
    function normalizeCountryName(name) {
      const countryNameMap = {
        'United States': 'USA',
        'South Korea': 'Korea, Republic of',
        'Russia': 'Russian Federation',
        'Iran': 'Iran, Islamic Republic of',
        'Czech Republic': 'Czechia'
        // Add more mappings here as needed
      };
      return countryNameMap[name] || name;
    }

    requestData();
  </script>
</body>
</html>