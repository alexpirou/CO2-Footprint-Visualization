<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Population vs C02 emissions analysis</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
        <script>

        var topology = topojson.topology({foo: geojson});

        </script>
        
  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>
</head>

<body>

  <svg id="co2" height="610" width="975" style="background: #fff; margin-top:50px"> </svg>
  <svg width="1000" height="1000" id="chart"></svg>

  <div>

    <script>

        // Carbon Emissions map
        const co2_svg = d3.select("#co2");
        const co2_width = co2_svg.attr("width");
        const co2_height = co2_svg.attr("height");
        const co2_mapWidth = co2_width;
        const co2_mapHeight = co2_height;
        // No margins here since our US map already has a specific projection to match to size
        const co2_map = co2_svg.append("g");

        // Function to load data and render the map
        async function requestDataFF() {
        // Load TopoJSON and COâ‚‚ emissions data
        const world = await d3.json("./countries-110m.json");
        const co2_emissions = await d3.csv("./co2_emissions_kt_by_country.csv", d3.autoType);

        // Use Mercator projection for a global map view
        const projection = d3.geoMercator()
                             .scale(200)
                             .translate([co2_width / 2, co2_height / 1.4]);

        const path = d3.geoPath().projection(projection);

        // Convert TopoJSON to GeoJSON for rendering each country
        const countries = topojson.feature(world, world.objects.countries).features;

        // Draw the countries with a default fill color
       co2_map.selectAll("path.country")
               .data(countries)
               .join("path")
               .attr("class", "country")
        }
        
         // 2. Make a contour map
        const requestDataFF = async function() {
      
        const us = await d3.json("../datasets/counties-10m.json");
        var projection = d3.geoAlbersUsa().scale(1300).translate([487.5, 305]);
        var path = d3.geoPath().projection(projection);
        var nation = topojson.feature(us, us.objects.nation);
        var statesMesh = topojson.mesh(us, us.objects.states);
        
        // Draw nation and state outlines
        co2_map.selectAll("path.nation").data(nation.features)
            .join("path")
            .attr("class", "nation")
            .attr("d", path);
        co2_map.append("path").datum(statesMesh)
                .attr("class","outline")
                .attr("d", path);
        

        var co2_emissions = await d3.csv("../datasets/co2_emissions_kt_by_country.csv", d3.autoType);
        console.log(co2_emissions)

        co2_emissions.forEach( (d, i) => {
        // Use the projection just like a scale to convert from lng/lat to pixels
        d.position = projection( [d.longitude, d.latitude] );
        });
      
        let contourGen = d3.contourDensity()
                         .x( d => d.position[0] )        // point x position (best in pixels)
                         .y( d => d.position[1] )        // point y position (best in pixels)
                         .size( [co2_width, co2_height] )    // size of canvas
                         .thresholds( 10 );    

        let contours = contourGen(co2_emissions);
        console.log(contours)

        let valueExtent = d3.extent(contours, d => d.value);
        let colorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent)
      
        let layer = co2_map.append("g");
      
        layer.selectAll("path.contours")
           .data(contours)
           .join("path")
           .attr("class", 'contours')
           .attr("fill", d => colorScale(d.value) )
           .attr("d", d3.geoPath())  

        co2_map.append("path").datum(statesMesh)
        .attr("class","outline")
        .attr("opacity", 0.5)
        .attr("d", path);
        }

        const svg = d3.select("svg");
        const width = svg.attr("width");
        const height = svg.attr("height");
        const margin = {top: 50, right: 100, bottom: 50, left: 100};
        const chartWidth = width - margin.left - margin.right;
        const chartHeight = height - margin.top - margin.bottom;

        let annotations = svg.append("g").attr("id","annotations");
        let chartArea = svg.append("g").attr("id","points")
                           .attr("transform",`translate(${margin.left},${margin.top})`);

        //Population levels plot
        d3.csv("world_population.csv", d3.autotype)
          .then((data) => {
            
            console.log(data);

            let populationYear = "2022 Population"; //Controls year being evaluated
            data.forEach( d => {
            d[populationYear] =  Number(d[populationYear]);
            });

            //Take the top countries
            const topCountries = data.sort((a,b) => b[populationYear] - a[populationYear]).slice(0, 10);

            console.log(topCountries);
            console.log('hello');
            console.log(d3.max(topCountries, d => d[populationYear]));

            // Define scales
            const populationScale = d3.scaleLinear()
                                      .domain([0, d3.max(topCountries, d => d[populationYear])])
                                      .range([0, chartWidth]);

            const countryScale = d3.scaleBand()
                                   .domain(topCountries.map(d => d['Country/Territory']))
                                   .range([0, chartHeight])
                                   .padding(0.5);

            const colorScale = d3.scaleOrdinal(d3.schemeCategory10); //Color scale

            //Create axes and gridlines
            let leftAxis = d3.axisLeft(countryScale);
            let leftGridlines = d3.axisLeft(countryScale).tickSize(-chartWidth-10).tickFormat("");
            annotations.append("g")
                       .attr("class", "y axis")
                       .attr("transform",`translate(${margin.left-10},${margin.top})`)
                       .call(leftAxis)
            annotations.append("g")
                       .attr("class", "y gridlines")
                       .attr("transform",`translate(${margin.left-10},${margin.top})`)
                       .call(leftGridlines);

            let bottomAxis = d3.axisBottom(populationScale)
                               .tickFormat(d3.format(".2s"));
            let bottomGridlines = d3.axisBottom(populationScale)
                                    .tickSize(-chartHeight-10)
                                    .tickFormat("");
            annotations.append("g")
                       .attr("class", "x axis")
                       .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                       .call(bottomAxis);
            annotations.append("g")
                       .attr("class", "x gridlines")
                       .attr("transform",`translate(${margin.left},${chartHeight+margin.top+10})`)
                       .call(bottomGridlines);

            //Add title
            chartArea.append("text")
                     .attr("x", chartWidth / 2)
                     .attr("y", margin.top - 75)
                     .attr("text-anchor", "middle")
                     .attr("font-size", "28px")
                     .text(populationYear);

            //Plot the rectangles. This is where we will make the changes for narrowing down to a single country for the user
            chartArea.selectAll('rect.bar').data(topCountries)
                     .join('rect').attr('class','bar')
                     .attr("x", 0)
                     .attr("y", d => countryScale(d['Country/Territory']))
                     .attr("fill", d => colorScale(d['Country/Territory']))
                     .attr("width", d => Math.min(populationScale(d[populationYear]), chartWidth))
                     .attr("height", countryScale.bandwidth());

            // Add population text inside each bar
            chartArea.selectAll('text.population').data(topCountries)
                 .join('text').attr('class', 'population')
                 .attr("x", d => populationScale(d[populationYear]) - 70)
                 .attr("y", d => countryScale(d['Country/Territory']) + countryScale.bandwidth() / 2 + 5)
                 .attr("fill", "black")
                 .attr("font-size", "12px")
                 .attr("text-anchor", "start")
                 .text(d => d3.format(",")(d[populationYear]));
          })
    </script>
  </div>

</body>

</html>