<!DOCTYPE html>
<html lang="en">

<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>Population vs CO2 Emissions Analysis</title>
  <script src="https://d3js.org/d3.v7.min.js"></script>
  <script src="https://unpkg.com/topojson@3"></script>
  
  <style>
    .gridlines line {
      stroke: #bbb;
    }

    .gridlines .domain {
      stroke: none;
    }
  </style>
</head>

<body>

  <svg id="co2" height="610" width="975" style="background: #fff; margin-top:50px"></svg>
  <svg width="1000" height="1000" id="chart"></svg>

  <script>
    //Map setup
    const co2_svg = d3.select("#co2");
    const co2_width = co2_svg.attr("width");
    const co2_height = co2_svg.attr("height");
    const co2_map = co2_svg.append("g");

    //Function to load data and render the map
    async function requestDataFF() {
      //Load TopoJSON and COâ‚‚ emissions data
      const world = await d3.json("./countries-110m.json");
      const co2_emissions_data = await d3.csv("./co2_emissions_kt_by_country.csv", d3.autoType);

      //Set up the Mercator projection
      const projection = d3.geoMercator()
                           .scale(200)
                           .translate([co2_width / 2, co2_height / 1.4]);

      const path = d3.geoPath().projection(projection);

      //Convert TopoJSON to GeoJSON for rendering each country
      const countries = topojson.feature(world, world.objects.countries).features;

      //Draw countries with default fill color
      co2_map.selectAll("path.country")
             .data(countries)
             .join("path")
             .attr("class", "country")
             .attr("d", path)
             .style("fill", "#ccc");  // Adding color to countries

      //Load US map (for the contour plot)
      const us = await d3.json("../datasets/counties-10m.json");
      const us_projection = d3.geoAlbersUsa().scale(1300).translate([487.5, 305]);
      const us_path = d3.geoPath().projection(us_projection);
      const nation = topojson.feature(us, us.objects.nation);
      const statesMesh = topojson.mesh(us, us.objects.states);

      //Draw US nation and state outlines
      co2_map.selectAll("path.nation")
             .data(nation.features)
             .join("path")
             .attr("class", "nation")
             .attr("d", us_path);

      co2_map.append("path")
             .datum(statesMesh)
             .attr("class", "outline")
             .attr("d", us_path);

      //Process CO2 emissions data for contour plot
      co2_emissions_data.forEach(d => {
        d.position = us_projection([d.longitude, d.latitude]);
      });

      const contourGen = d3.contourDensity()
                           .x(d => d.position[0])
                           .y(d => d.position[1])
                           .size([co2_width, co2_height])
                           .thresholds(10);

      const contours = contourGen(co2_emissions_data);

      const valueExtent = d3.extent(contours, d => d.value);
      const colorScale = d3.scaleSequential(d3.interpolateViridis).domain(valueExtent);

      const contourLayer = co2_map.append("g");

      contourLayer.selectAll("path.contours")
                  .data(contours)
                  .join("path")
                  .attr("class", "contours")
                  .attr("fill", d => colorScale(d.value))
                  .attr("d", d3.geoPath());

      //Overlay states outline with opacity
      co2_map.append("path")
             .datum(statesMesh)
             .attr("class", "outline")
             .attr("opacity", 0.5)
             .attr("d", us_path);
    }

    //Call the requestDataFF function to load + render the map
    requestDataFF();

    //Population chart setup
    const svg = d3.select("#chart");
    const width = svg.attr("width");
    const height = svg.attr("height");
    const margin = {top: 50, right: 100, bottom: 50, left: 100};
    const chartWidth = width - margin.left - margin.right;
    const chartHeight = height - margin.top - margin.bottom;

    const annotations = svg.append("g").attr("id", "annotations");
    const chartArea = svg.append("g").attr("id", "points")
                         .attr("transform", `translate(${margin.left}, ${margin.top})`);

    //Population levels plot
    d3.csv("world_population.csv", d3.autoType)
      .then((data) => {
        const populationYear = "2022 Population";  // Controls year being evaluated
        data.forEach(d => {
          d[populationYear] = Number(d[populationYear]);
        });

        //Take the top countries
        const topCountries = data.sort((a, b) => b[populationYear] - a[populationYear]).slice(0, 10);

        //Define scales
        const populationScale = d3.scaleLinear()
                                  .domain([0, d3.max(topCountries, d => d[populationYear])])
                                  .range([0, chartWidth]);

        const countryScale = d3.scaleBand()
                               .domain(topCountries.map(d => d['Country/Territory']))
                               .range([0, chartHeight])
                               .padding(0.5);

        const colorScale = d3.scaleOrdinal(d3.schemeCategory10);  // Color scale

        //Create axes and gridlines
        const leftAxis = d3.axisLeft(countryScale);
        const leftGridlines = d3.axisLeft(countryScale)
                               .tickSize(-chartWidth - 10)
                               .tickFormat("");
        annotations.append("g")
                   .attr("class", "y axis")
                   .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
                   .call(leftAxis);

        annotations.append("g")
                   .attr("class", "y gridlines")
                   .attr("transform", `translate(${margin.left - 10}, ${margin.top})`)
                   .call(leftGridlines);

        const bottomAxis = d3.axisBottom(populationScale).tickFormat(d3.format(".2s"));
        const bottomGridlines = d3.axisBottom(populationScale)
                                 .tickSize(-chartHeight - 10)
                                 .tickFormat("");
        annotations.append("g")
                   .attr("class", "x axis")
                   .attr("transform", `translate(${margin.left}, ${chartHeight + margin.top + 10})`)
                   .call(bottomAxis);

        annotations.append("g")
                   .attr("class", "x gridlines")
                   .attr("transform", `translate(${margin.left}, ${chartHeight + margin.top + 10})`)
                   .call(bottomGridlines);

        //Add title to plot
        chartArea.append("text")
                 .attr("x", chartWidth / 2)
                 .attr("y", margin.top - 75)
                 .attr("text-anchor", "middle")
                 .attr("font-size", "28px")
                 .text(populationYear);

        //Plot the rectangles aka bars
        chartArea.selectAll('rect.bar')
                 .data(topCountries)
                 .join('rect')
                 .attr('class', 'bar')
                 .attr("x", 0)
                 .attr("y", d => countryScale(d['Country/Territory']))
                 .attr("fill", d => colorScale(d['Country/Territory']))
                 .attr("width", d => Math.min(populationScale(d[populationYear]), chartWidth))
                 .attr("height", countryScale.bandwidth());

        //Add population text inside each bar
        chartArea.selectAll('text.population')
                 .data(topCountries)
                 .join('text')
                 .attr('class', 'population')
                 .attr("x", d => populationScale(d[populationYear]) - 70)
                 .attr("y", d => countryScale(d['Country/Territory']) + countryScale.bandwidth() / 2 + 5)
                 .attr("fill", "black")
                 .attr("font-size", "12px")
                 .attr("text-anchor", "start")
                 .text(d => d3.format(",")(d[populationYear]));
      });
  </script>

</body>
</html>